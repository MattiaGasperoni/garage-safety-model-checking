--------------------------------------------------------------------------
-- MODELLO UL 325 - GARAGE DOOR SAFETY SYSTEM
-- Progetto di Linguaggi di Programmazione e Verifica del Software
--------------------------------------------------------------------------
-- Sistema di controllo porta da garage conforme allo standard UL 325
-- con particolare attenzione ai requisiti di sicurezza (entrapment protection).
--
-- STRUTTURA:
-- - Controller: gestisce i comandi dell'utente
-- - Door: meccanismo porta con sensori e logica di sicurezza
--
-- MIGLIORAMENTI RISPETTO AL MODELLO BASE:
-- 1. Posizione esplicita della porta (0-10 unità)
-- 2. Sensori di fine corsa (top_sensor, bottom_sensor)
-- 3. Gestione più realistica del movimento
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-- MODULO CONTROLLER
--------------------------------------------------------------------------
MODULE Controller(door_state, door_position)

VAR
    -- Comandi disponibili per l'utente
    -- START_OPEN  : avvia apertura
    -- START_CLOSE : avvia chiusura  
    -- STOP        : arresta movimento
    -- RESET       : sblocca dopo blocco di sicurezza
    command : {START_CLOSE, START_OPEN, STOP, RESET};

    -- I comandi sono non deterministici per simulare input utente imprevedibile
    -- ma con vincoli di fairness per evitare comportamenti irrealistici

    -- Vincoli di fairness
    FAIRNESS !(command = STOP);      -- STOP non premuto all'infinito
    FAIRNESS command = RESET;        -- RESET viene eventualmente premuto se necessario


--------------------------------------------------------------------------
-- MODULO DOOR
--------------------------------------------------------------------------
MODULE Door(command, force_limit_exceeded, photo_eye_broken)

VAR
    -- Stato della porta
    state : {IDLE, CLOSING, OPENING, REVERSING, STOPPED_BY_OBSTACLE};
    
    -- Posizione della porta: 0 = completamente chiusa, 10 = completamente aperta
    -- Questo permette di modellare meglio il movimento e i sensori di fine corsa
    position : 0..10;
    
    -- Contatore ostacoli consecutivi durante chiusura
    obstacle_counter : 0..2;

DEFINE
    -- Sensori di fine corsa (derivati dalla posizione)
    top_sensor := (position = 10);      -- Porta completamente aperta
    bottom_sensor := (position = 0);    -- Porta completamente chiusa
    
    -- Allarme di sicurezza (attivo quando obstacle_counter = 2)
    alarm := (obstacle_counter = 2);
    
    -- Condizione ostacolo (almeno uno dei due sensori attivato)
    obstacle := (force_limit_exceeded | photo_eye_broken);

ASSIGN
    init(state) := IDLE;
    init(position) := 5;              -- Posizione iniziale intermedia
    init(obstacle_counter) := 0;

    --------------------------------------------------------------------------
    -- FUNZIONE DI TRANSIZIONE DELLO STATO
    -- Implementa le regole UL 325
    --------------------------------------------------------------------------
    next(state) :=
        case
            -- Secondo ostacolo durante chiusura: blocco di sicurezza
            state = CLOSING & obstacle & obstacle_counter = 1 : 
                STOPPED_BY_OBSTACLE;

            -- Primo ostacolo durante chiusura: inversione immediata
            state = CLOSING & obstacle & obstacle_counter = 0 : 
                REVERSING;

            -- Fine fase di reversing: passa ad apertura
            state = REVERSING : 
                OPENING;

            -- Uscita da blocco di sicurezza solo con RESET
            state = STOPPED_BY_OBSTACLE & command = RESET : 
                IDLE;
            state = STOPPED_BY_OBSTACLE : 
                STOPPED_BY_OBSTACLE;

            -- Avvio chiusura da IDLE
            -- Richiede: non già chiusa, nessun ostacolo presente
            state = IDLE & command = START_CLOSE & !bottom_sensor & !obstacle : 
                CLOSING;

            -- Avvio apertura da IDLE
            -- Richiede: non già aperta
            state = IDLE & command = START_OPEN & !top_sensor : 
                OPENING;

            -- Comando STOP durante movimento
            (state = CLOSING | state = OPENING) & command = STOP : 
                IDLE;

            -- Fine corsa durante apertura
            state = OPENING & top_sensor : 
                IDLE;

            -- Fine corsa durante chiusura (chiusura completata con successo)
            state = CLOSING & bottom_sensor : 
                IDLE;

            -- Mantiene stato corrente negli altri casi
            TRUE : 
                state;
        esac;

    --------------------------------------------------------------------------
    -- AGGIORNAMENTO POSIZIONE
    --------------------------------------------------------------------------
    next(position) :=
        case
            -- Apertura: incrementa posizione fino a 10
            (state = OPENING | state = REVERSING) & position < 10 : 
                position + 1;

            -- Chiusura: decrementa posizione fino a 0
            state = CLOSING & position > 0 : 
                position - 1;

            -- Reset dopo blocco: torna a posizione intermedia
            state = STOPPED_BY_OBSTACLE & command = RESET : 
                5;

            -- Altrimenti mantiene posizione
            TRUE : 
                position;
        esac;

    --------------------------------------------------------------------------
    -- CONTATORE OSTACOLI
    --------------------------------------------------------------------------
    next(obstacle_counter) :=
        case
            -- Incrementa quando rileva ostacolo durante chiusura
            state = CLOSING & obstacle & obstacle_counter < 2 : 
                obstacle_counter + 1;

            -- Reset dopo chiusura completata con successo
            state = CLOSING & next(state) = IDLE & bottom_sensor : 
                0;

            -- Reset manuale dopo uscita da blocco
            state = STOPPED_BY_OBSTACLE & command = RESET : 
                0;

            -- Mantiene valore negli altri casi
            TRUE : 
                obstacle_counter;
        esac;


--------------------------------------------------------------------------
-- MODULO MAIN
--------------------------------------------------------------------------
MODULE main

VAR
    -- Sensori ambientali (modellati come input non deterministici)
    force_limit_exceeded : boolean;   -- Sensore di forza (primary entrapment)
    photo_eye_broken : boolean;       -- Fotocellula (secondary entrapment)
    
    -- Istanze dei moduli
    D : Door(C.command, force_limit_exceeded, photo_eye_broken);
    C : Controller(D.state, D.position);

    -- Vincoli di fairness sui sensori
    -- Gli ostacoli non rimangono attivi per sempre (vengono rimossi)
    FAIRNESS !force_limit_exceeded;
    FAIRNESS !photo_eye_broken;


--------------------------------------------------------------------------
-- PROPRIETÀ DI VERIFICA
--------------------------------------------------------------------------

---------------------------------------------------------------------------
-- SAFETY PROPERTIES
---------------------------------------------------------------------------

-- [S1] La porta non deve chiudersi spontaneamente
-- Se siamo in IDLE senza comando START_CLOSE, non possiamo passare a CLOSING
CTLSPEC
    AG (D.state = IDLE & C.command != START_CLOSE -> AX D.state != CLOSING)

-- [S2] Non è possibile passare direttamente da CLOSING a OPENING
-- (deve passare per REVERSING o IDLE)
CTLSPEC
    AG (D.state = CLOSING -> !EX D.state = OPENING)

-- [S3] Se c'è un ostacolo, il comando START_CLOSE viene ignorato
CTLSPEC
    AG ((C.command = START_CLOSE & (force_limit_exceeded | photo_eye_broken)) 
        -> AX D.state != CLOSING)

-- [S4] L'allarme rimane attivo finché non arriva RESET
CTLSPEC
    AG (D.alarm -> A[D.alarm U C.command = RESET])

-- [S5] Dal blocco di sicurezza si esce solo con RESET
CTLSPEC
    AG (D.state = STOPPED_BY_OBSTACLE -> A[D.state = STOPPED_BY_OBSTACLE U C.command = RESET])



---------------------------------------------------------------------------
-- LIVENESS PROPERTIES  
---------------------------------------------------------------------------

-- [L1] Il sistema torna sempre eventualmente a IDLE
-- (non ci sono deadlock)
CTLSPEC
    AG AF D.state = IDLE

-- [L2] Ogni apertura termina prima o poi
CTLSPEC
    AG (D.state = OPENING -> AF D.state = IDLE)

-- [L3] Se la porta è in REVERSING, prima o poi passa ad OPENING
CTLSPEC
    AG (D.state = REVERSING -> AF D.state = OPENING)



---------------------------------------------------------------------------
-- UL 325 COMPLIANCE
---------------------------------------------------------------------------

-- [UL1] Primary Entrapment Protection
-- Se durante chiusura si rileva forza eccessiva, si deve invertire immediatamente
LTLSPEC
    G ((D.state = CLOSING & force_limit_exceeded & D.obstacle_counter = 0) 
       -> X D.state = REVERSING)

-- [UL2] Secondary Entrapment Protection  
-- Se durante chiusura si rompe la fotocellula, si deve invertire immediatamente
LTLSPEC
    G ((D.state = CLOSING & photo_eye_broken & D.obstacle_counter = 0) 
       -> X D.state = REVERSING)

-- [UL3] Il contatore ostacoli deve passare da 0 a 1 prima di arrivare a 2
-- (non può saltare valori)
LTLSPEC
    !((!(D.obstacle_counter = 1)) U (D.obstacle_counter = 2))

-- [UL4] Con fotocellula rotta, la porta non può essere in chiusura
LTLSPEC
    G ((D.state = CLOSING & photo_eye_broken) -> X (D.state != CLOSING))



---------------------------------------------------------------------------
-- ADDITIONAL PROPERTIES
---------------------------------------------------------------------------

-- [A1] Durante apertura non si può passare a chiusura senza fermarsi
LTLSPEC
    G (D.state = OPENING -> (D.state != CLOSING U D.state = IDLE))

-- [A2] La posizione rimane nei limiti [0, 10]
CTLSPEC
    AG (D.position >= 0 & D.position <= 10)