--------------------------------------------------------------------------
-- MODELLO: UL 325 - GARAGE DOOR SAFETY SYSTEM
-- CORSO:   Linguaggi di Programmazione e Verifica del Software
--------------------------------------------------------------------------
-- DESCRIZIONE:
-- Modellazione di un sistema di controllo per porta da garage conforme 
-- allo standard di sicurezza UL 325, il focus è sulla protezione 
-- contro l'intrappolamento (entrapment protection).
--
-- ARCHITETTURA:
-- 1. Controller: Modella l'input utente e la logica di comando.
-- 2. Door:       Modella la fisica della porta, i sensori e gli attuatori.
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-- MODULO: CONTROLLER
-- Questo modulo simula il comportamento dell'utente e la logica di comando.
--------------------------------------------------------------------------
-- PARAMETRI:
-- door_state    : Lo stato attuale della porta
-- door_position : La posizione discreta della porta (0..10)
--------------------------------------------------------------------------
MODULE Controller(door_state, door_position)

VAR
    -- Variabile di stato che rappresenta l'input dell'utente.
    -- START_OPEN  : Richiesta di apertura porta
    -- START_CLOSE : Richiesta di chiusura porta
    -- STOP        : Richiesta di arresto immediato
    -- RESET       : Richiesta di ripristino dopo un errore/blocco
    command : {START_CLOSE, START_OPEN, STOP, RESET};

    -- Il valore di 'command' è scelto non-deterministicamente ad ogni passo
    -- per coprire tutti i possibili scenari di interazione utente


    -- VINCOLI DI FAIRNESS
    -- Necessari per escludere scenari di simulazione non realistici che impedirebbero la verifica delle proprietà.

    -- 1. Evita che il tasto STOP rimanga premuto per sempre
    --    Garantisce che il sistema abbia la possibilità di ricevere altri input
    FAIRNESS !(command = STOP); 
    
    -- 2. Garantisce che il comando RESET venga provato infinite volte
    --    Assicura che, se il sistema entra in stato di blocco, l'utente
    --    tenterà eventualmente di sbloccarlo (evita deadlock dovuti all'inazione)
    FAIRNESS command = RESET;


--------------------------------------------------------------------------
-- MODULO: DOOR
-- Gestisce la fisica della porta, la logica degli stati e i sensori
--------------------------------------------------------------------------
-- PARAMETRI:
-- command              : Input dal Controller
-- force_limit_exceeded : Input ambientale (sensore di contatto/forza)
-- photo_eye_broken     : Input ambientale (sensore ottico)
--------------------------------------------------------------------------
MODULE Door(command, force_limit_exceeded, photo_eye_broken)

VAR
    -- Stati della porta:
    -- IDLE                : Porta ferma e sicura
    -- CLOSING/OPENING     : In movimento
    -- REVERSING           : Inversione di sicurezza dopo ostacolo
    -- STOPPED_BY_OBSTACLE : Stato di attesa dopo un ostacolo
    state : {IDLE, CLOSING, OPENING, REVERSING, STOPPED_BY_OBSTACLE};
    
    -- Posizione della porta nell'intervallo 0..10 per permettere la verifica di stati intermedi
    -- 0  = Completamente Chiusa
    -- 10 = Completamente Aperta
    position : 0..10;
    
    -- Contatore per la logica "Double Entrapment" (UL 325)
    -- Traccia quante volte consecutive la porta incontra un ostacolo, se raggiunge 2 ostacoli, il sistema deve entrare in blocco
    obstacle_counter : 0..2;

DEFINE
    -- Sensori di fine corsa, si basano sulla posizione della porta
    top_sensor    := (position = 10);    -- Rileva apertura completa
    bottom_sensor := (position = 0);     -- Rileva chiusura completa
    
    -- Segnale di allarme/blocco
    -- Attivo quando si verificano due incidenti consecutivi senza una chiusura riuscita
    alarm := (obstacle_counter = 2);
    
    -- Segnale aggregato di rilevamento ostacolo
    -- TRUE se il sensore di forza (contatto) o la fotocellula (non contatto) scattano
    obstacle := (force_limit_exceeded | photo_eye_broken);

ASSIGN
    -- Inizializzazione del sistema:
    -- La porta parte ferma, chiusa e senza errori pregressi.
    init(state)            := IDLE;
    init(position)         := 0;              
    init(obstacle_counter) := 0;

    --------------------------------------------------------------------------
    -- FUNZIONE DI TRANSIZIONE DELLO STATO
    -- Implementa le regole UL 325
    --------------------------------------------------------------------------
    next(state) :=
        case
            -- Quando rileviamo il secondo ostacolo durante la chiusura la porta va in blocco di sicurezza
            state = CLOSING & obstacle & obstacle_counter = 1 : 
                STOPPED_BY_OBSTACLE;

            -- Quando rileviamo il primo ostacolo durante la chiusura la porta va in inversione immediata
            state = CLOSING & obstacle & obstacle_counter = 0 : 
                REVERSING;

            -- Fine fase di inversione si passa ad apertura
            state = REVERSING : 
                OPENING;

            -- Uscita da blocco di sicurezza solo se l'utente preme RESET
            state = STOPPED_BY_OBSTACLE & command = RESET : 
                IDLE;

            -- La porta rimane in blocco finche l'utente non preme RESET
            state = STOPPED_BY_OBSTACLE : 
                STOPPED_BY_OBSTACLE;

            -- Avvio chiusura da IDLE
            -- Richiede che la porta non sia già chiusa e non ci sia nessun ostacolo presente
            state = IDLE & command = START_CLOSE & !bottom_sensor & !obstacle : 
                CLOSING;

            -- Avvio apertura da IDLE
            -- Richiede che la porta non sia già aperta
            state = IDLE & command = START_OPEN & !top_sensor : 
                OPENING;

            -- Comando STOP durante movimento
            (state = CLOSING | state = OPENING) & command = STOP : 
                IDLE;

            -- Raggiunto il fine corsa durante l'apertura
            state = OPENING & top_sensor : 
                IDLE;

            -- Raggiunto il fine corsa durante la chiusura (chiusura completata con successo)
            state = CLOSING & bottom_sensor : 
                IDLE;

            -- Mantiene lo stato corrente negli altri casi
            TRUE : 
                state;
        esac;

    --------------------------------------------------------------------------
    -- AGGIORNAMENTO POSIZIONE
    --------------------------------------------------------------------------
    next(position) :=
        case
            -- Apertura porta: incrementa la posizione fino a 10 (totalmente aperta)
            (state = OPENING | state = REVERSING) & position < 10 : 
                position + 1;

            -- Chiusura porta: decrementa la posizione fino a 0 (totalmente chiusa)
            state = CLOSING & position > 0 : 
                position - 1;

            -- Altrimenti mantiene la posizione attaule della porta (incluso quando l'utente preme RESET)
            TRUE : 
                position;
        esac;

    --------------------------------------------------------------------------
    -- CONTATORE OSTACOLI
    --------------------------------------------------------------------------
    next(obstacle_counter) :=
        case
            -- Incrementa il contatore quando rileva un ostacolo durante la chiusura
            state = CLOSING & obstacle & obstacle_counter < 2 : 
                obstacle_counter + 1;

            -- Quando la porta viene chiusa con successo resetta il counter degli ostacoli
            state = CLOSING & next(state) = IDLE & bottom_sensor : 
                0;

            -- Quando l'utente preme RESET si resetta il counter degli ostacoli
            state = STOPPED_BY_OBSTACLE & command = RESET : 
                0;

            -- Mantiene il valore negli altri casi
            TRUE : 
                obstacle_counter;
        esac;


--------------------------------------------------------------------------
-- MODULO: MAIN
-- Punto di ingresso della simulazione.
-- Integra il Controller e la Porta in un ciclo di controllo.
--------------------------------------------------------------------------
MODULE main

VAR
    ----------------------------------------------------------------------
    -- Sensori Ambientali
    ----------------------------------------------------------------------
    force_limit_exceeded : boolean;   -- TRUE se la porta urta un oggetto (sensore di forza/contatto)
    photo_eye_broken     : boolean;   -- TRUE se il raggio ottico viene interrotto (presenza di un ostacolo)

    ----------------------------------------------------------------------
    -- Istanze dei moduli
    ----------------------------------------------------------------------
    D : Door(C.command, force_limit_exceeded, photo_eye_broken);
    C : Controller(D.state, D.position);


    -- VINCOLI DI FAIRNESS
    -- Necessari per la verifica delle proprietà di liveness
    -- Senza queste fairness, il model checker genererebbe controesempi banali
    -- in cui un ostacolo rimane presente per sempre, impedendo la chiusura.
    
    -- Assunzione: L'ostacolo fisico viene eventualmente rimosso
    FAIRNESS !force_limit_exceeded;
    
    -- Assunzione: L'interruzione della fotocellula è temporanea
    FAIRNESS !photo_eye_broken;


--------------------------------------------------------------------------
-- PROPRIETÀ DI VERIFICA
--------------------------------------------------------------------------

---------------------------------------------------------------------------
-- SAFETY PROPERTIES
---------------------------------------------------------------------------

-- [SP 1] No chiusura spontanea
-- La porta non può iniziare a chiudersi senza un comando esplicito START_CLOSE
CTLSPEC
    AG (D.state = IDLE & C.command != START_CLOSE -> AX D.state != CLOSING)

-- [SP 2] No inversione diretta
-- Per cambiare direzione (CLOSING→OPENING) serve passare per REVERSING o IDLE
CTLSPEC
    AG (D.state = CLOSING -> !EX D.state = OPENING)

-- [SP 3] Blocco preventivo
-- START_CLOSE viene ignorato se c'è già un ostacolo rilevato
CTLSPEC
    AG ((C.command = START_CLOSE & (force_limit_exceeded | photo_eye_broken)) 
        -> AX D.state != CLOSING)

-- [SP 4] Persistenza allarme
-- L'allarme di sicurezza non si disattiva da solo, richiede RESET esplicito
CTLSPEC
    AG (D.alarm -> A[D.alarm U C.command = RESET])

-- [SP 5] Sblocco manuale obbligatorio
-- Dopo un blocco di sicurezza, solo RESET permette di uscire dallo stato bloccato
CTLSPEC
    AG (D.state = STOPPED_BY_OBSTACLE -> A[D.state = STOPPED_BY_OBSTACLE U C.command = RESET])



---------------------------------------------------------------------------
-- LIVENESS PROPERTIES  
---------------------------------------------------------------------------

-- [LP 1] Assenza di deadlock
-- Il sistema torna sempre eventualmente a IDLE (nessuno stato di blocco permanente)
CTLSPEC
    AG AF D.state = IDLE

-- [LP 2] Completamento apertura
-- Ogni operazione di apertura termina sempre, tornando a IDLE
CTLSPEC
    AG (D.state = OPENING -> AF D.state = IDLE)

-- [LP 3] Progressione inversione
-- Dopo REVERSING, il sistema passa sempre ad OPENING (inversione completa)
CTLSPEC
    AG (D.state = REVERSING -> AF D.state = OPENING)



---------------------------------------------------------------------------
-- UL 325 COMPLIANCE
---------------------------------------------------------------------------

-- [UL 1] Primary Entrapment Protection (sensore di forza)
-- Un rilevamento di forza eccessiva implica una inversione immediata nel ciclo successivo
LTLSPEC
    G ((D.state = CLOSING & force_limit_exceeded & D.obstacle_counter = 0) 
       -> X D.state = REVERSING)

-- [UL 2] Secondary Entrapment Protection (fotocellula)
-- Un'nterruzione del fascio infrarosso implica una inversione immediata nel ciclo successivo
LTLSPEC
    G ((D.state = CLOSING & photo_eye_broken & D.obstacle_counter = 0) 
       -> X D.state = REVERSING)

-- [UL 3] Progressione contatore ostacoli
-- Il contatore deve incrementare gradualmente: 0 → 1 → 2 non deve effettuare dei salti
LTLSPEC
    !((!(D.obstacle_counter = 1)) U (D.obstacle_counter = 2))

-- [UL 4] Divieto chiusura con fotocellula attiva
-- Quando il fascio infrarosso è interrotto, lo stato CLOSING è impossibile
LTLSPEC
    G ((D.state = CLOSING & photo_eye_broken) -> X (D.state != CLOSING))



---------------------------------------------------------------------------
-- ADDITIONAL PROPERTIES
---------------------------------------------------------------------------

-- [AP 1] Controllo movimento
-- Durante l'apertura è impossibile passare alla chiusura senza tornare prima a IDLE
LTLSPEC
    G (D.state = OPENING -> (!(D.state = CLOSING) U D.state = IDLE))

-- [AP 2] Controllo posizione
-- La posizione deve sempre rimanere nel range valido [0, 10]
CTLSPEC
    AG (D.position >= 0 & D.position <= 10)
